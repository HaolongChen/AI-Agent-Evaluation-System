generator client {
  provider = "prisma-client-js"
  output   = "../src/generated/prisma"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL_DEVELOPMENT")
}

enum CopilotType {
  dataModel
  uiBuilder
  actionflow
  logAnalyzer
  agentBuilder
}

enum SessionStatus {
  running
  completed
  failed
  pending
}

enum EvaluationStatus {
  pending
  in_progress
  completed
  failed
}

enum RubricReviewStatus {
  pending
  approved
  rejected
  modified
}

enum ExpectedAnswer {
  yes
  no
}

model goldenSet {
  id             BigInt      @id @default(autoincrement())
  projectExId    String      @map("project_ex_id")
  schemaExId     String      @map("schema_ex_id")
  copilotType    CopilotType @map("copilot_type")
  description    String?
  promptTemplate String      @map("prompt_template")
  idealResponse  Json        @map("ideal_response")
  createdAt      DateTime    @default(now()) @map("created_at") @db.Timestamptz(6)
  createdBy      String?     @map("created_by")
  isActive       Boolean     @default(true) @map("is_active")

  @@unique([projectExId, schemaExId, copilotType])
  @@index([schemaExId], map: "idx_golden_set_schema")
}

// Execution Sessions (references copilot schema tables)
model evaluationSession {
  id           BigInt        @id @default(autoincrement())
  projectExId  String        @map("project_ex_id")
  schemaExId   String        @map("schema_ex_id")
  copilotType  CopilotType   @map("copilot_type")
  modelName    String        @map("model_name") // e.g., 'gpt-4', 'claude-3-opus'
  sessionIdRef BigInt?       @map("session_id_ref") // Reference to copilot_session.id
  startedAt    DateTime      @default(now()) @map("started_at") @db.Timestamptz(6)
  completedAt  DateTime?     @map("completed_at") @db.Timestamptz(6)
  status       SessionStatus @default(running)

  // Performance Metrics
  totalLatencyMs    Int?     @map("total_latency_ms")
  roundtripCount    Int?     @map("roundtrip_count")
  inputTokens       Int?     @map("input_tokens")
  outputTokens      Int?     @map("output_tokens")
  totalTokens       Int?     @map("total_tokens") // input_tokens + output_tokens + reasoning tokens
  contextPercentage Decimal? @map("context_percentage") @db.Decimal(5, 2) // % of max context window used

  // Metadata
  // metadata Json? TODO: figure out what metadata to store

  // Relations
  rubrics adaptiveRubric[]
  result  evaluationResult?

  @@index([schemaExId], map: "idx_evaluation_session_schema")
}

// Adaptive Rubrics (AI-generated evaluation questions)
model adaptiveRubric {
  id          BigInt @id @default(autoincrement())
  projectExId String @map("project_ex_id")
  schemaExId  String @map("schema_ex_id")
  sessionId   BigInt @map("session_id")

  // Rubric Content
  content        String[] // The actual question/rubric
  rubricType     String[] @map("rubric_type") // e.g., 'completeness', 'correctness', 'naming_convention'
  category       String[] // e.g., 'entity_coverage', 'attribute_completeness'
  expectedAnswer ExpectedAnswer[] @map("expected_answer")

  // Status
  reviewStatus RubricReviewStatus @default(pending) @map("review_status") 
  isActive     Boolean @default(true) @map("is_active")

  // Timestamps
  generatedAt DateTime  @default(now()) @map("generated_at") @db.Timestamptz(6)
  reviewedAt  DateTime? @map("reviewed_at") @db.Timestamptz(6)
  reviewedBy  String?   @map("reviewed_by") // account ID of the reviewer

  // Relations
  session      evaluationSession             @relation(fields: [sessionId], references: [id])
  judgeRecords adaptiveRubricJudgeRecord[] @relation("judgeRecords")

  @@index([sessionId], map: "idx_adaptive_rubric_session")
}

// Rubric Judgments (human reviews)
model adaptiveRubricJudgeRecord {
  id               BigInt   @id @default(autoincrement())
  adaptiveRubricId BigInt   @map("adaptive_rubric_id")
  accountId        String   @map("account_id") // ID of the human judge but probably unnecessary to store
  result           Boolean // true = pass, false = fail
  confidenceScore  Decimal[] @map("confidence_score") @db.Decimal(5, 2) // 0.00 - 1.00 scale
  notes            String?
  judgedAt         DateTime @default(now()) @map("judged_at") @db.Timestamptz(6)

  // Relations
  rubric adaptiveRubric @relation(fields: [adaptiveRubricId], references: [id], name: "judgeRecords")

  @@index([adaptiveRubricId], map: "idx_rubric_judge_rubric")
}

// Evaluation Results Summary (aggregated metrics)
model evaluationResult {
  id         BigInt @id @default(autoincrement())
  sessionId  BigInt @unique @map("session_id")
  schemaExId String @map("schema_ex_id")

  evaluationStatus EvaluationStatus @default(pending) @map("evaluation_status")

  // Quality Metrics (specific to copilot type)
  metrics Json // Flexible storage for different metric types
  // Examples:
  // Data Model Builder: {
  //   "entity_coverage": 0.95,
  //   "attribute_completeness": 0.87,
  //   "naming_convention_adherence": 0.92,
  //   "relational_integrity": 0.88,
  //   "normalization_level": 0.85
  // }
  // UI Builder: {
  //   "component_choice_relevance": 0.91,
  //   "layout_coherence": 0.89,
  //   "style_adherence": 0.94,
  //   "responsiveness_check": 0.86
  // }
  // Actionflow Builder: {
  //   "task_adherence": 0.93,
  //   "logical_correctness": 0.90,
  //   "efficiency": 0.85
  // }
  // combination of copilot types, categories, and their respective scores can be stored here

  // Overall Score
  overallScore Decimal @map("overall_score") @db.Decimal(5, 2)

  createdAt DateTime @default(now()) @map("created_at") @db.Timestamptz(6)

  // Relations
  session evaluationSession @relation(fields: [sessionId], references: [id])
}
